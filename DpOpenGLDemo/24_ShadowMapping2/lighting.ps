#version 330

const int MAX_POINT_LIGHTS = 2;
const int MAX_SPOT_LIGHTS = 2;

in vec4 LightSpacePos;
in vec2 TexCoord0;
in vec3 Normal0;
in vec3 WorldPos0;

out vec4 FragColor;

struct BaseLight
{
	vec3 color;
	float ambientIntensity;
	float diffuseIntensity;
};

struct DirectionalLight
{
	BaseLight base;
	vec3 direction;
};

struct Attenuation
{
	float kc;
	float kl;
	float kq;
};

struct PointLight
{
	BaseLight base;
	vec3 position;
	Attenuation atten;
};

struct SpotLight
{
	PointLight pl;
	vec3 direction;
	float cutoff;
};

uniform int gNumPointLights;
uniform int gNumSpotLights;
uniform sampler2D gSampler;
uniform sampler2D gShadowMap;
uniform vec3 gEyeWorldPos;
uniform float gSpecularIntensity;
uniform float gSpecularPower;
uniform DirectionalLight gDirectionalLight;
uniform PointLight gPointLights[MAX_POINT_LIGHTS];
uniform SpotLight gSpotLights[MAX_SPOT_LIGHTS];

float CalcShadowFactor(vec4 lightSpacePos)
{
	vec3 projCoords = lightSpacePos.xyz / lightSpacePos.w;
	vec2 uvCoords;
	uvCoords.x = 0.5 * projCoords.x + 0.5;
	uvCoords.y = 0.5 * projCoords.y + 0.5;
	float z = 0.5 * projCoords.z + 0.5;
	float depth = texture(gShadowMap, uvCoords).x;
	if (depth < z + 0.00001)
		return 0.5;
	else
		return 1.0; 
}

vec4 CalcLightInternal(BaseLight light, vec3 lightDirection, vec3 normal, float shadowFactor)
{
	vec4 ambientColor = vec4(light.color * light.ambientIntensity, 1.0f);
	
	vec4 diffuseColor = vec4(0, 0, 0, 0);
	vec4 specularColor = vec4(0, 0, 0, 0);
	float k = dot(-lightDirection, normal);
	if (k > 0)
	{
		diffuseColor = vec4(light.color * light.diffuseIntensity * k, 1.0f);

		vec3 vertexToEye = normalize(gEyeWorldPos - WorldPos0);
		vec3 lightReflect = normalize(lightDirection - 2 * normal * dot(normal, lightDirection));
		k = dot(vertexToEye, lightReflect);
		if (k > 0)
		{
			k = pow(k, gSpecularPower);
			specularColor = vec4(light.color * gSpecularIntensity * k, 1.0f);
		}
	}

	return (ambientColor + shadowFactor * (diffuseColor + specularColor));
}

vec4 CalcDirectionLight(vec3 normal)
{
	return CalcLightInternal(gDirectionalLight.base, gDirectionalLight.direction, normal, 1.0);
}

vec4 CalcPointLight(PointLight pl, vec3 normal, vec4 lightSpacePos)
{
	vec3 lightDirection = WorldPos0 - pl.position;
	float distance = length(lightDirection);
	lightDirection = normalize(lightDirection);
	float shadowFactor = CalcShadowFactor(lightSpacePos);

	vec4 color = CalcLightInternal(pl.base, lightDirection, normal, shadowFactor);
	float k = pl.atten.kc + pl.atten.kl * distance + pl.atten.kq * distance * distance;

	return color / k;
}

vec4 CalcSpotLight(SpotLight sl, vec3 normal, vec4 lightSpacePos)
{
	vec3 lightToPixel = normalize(WorldPos0 - sl.pl.position);
	float k = dot(lightToPixel, sl.direction);

	if (k > sl.cutoff)
	{
		vec4 color = CalcPointLight(sl.pl, normal, lightSpacePos);
		return color * (1.0 - (1.0 - k) * 1.0 / (1.0 - sl.cutoff));
	}
	else
	{
		return vec4(0,0,0,0);
	}
}

void main()
{
	vec3 normal = normalize(Normal0);
	vec4 totalLight = CalcDirectionLight(normal);

	for(int i = 0; i < gNumPointLights; ++i)
	{
		totalLight += CalcPointLight(gPointLights[i], normal, LightSpacePos);
	}

	for(int i = 0; i < gNumSpotLights; ++i)
	{
		totalLight += CalcSpotLight(gSpotLights[i], normal, LightSpacePos);
	}

//	totalLight = vec4(1.0f);

	FragColor = texture2D(gSampler, TexCoord0.xy) * totalLight;
}